<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC DataChannel</title>
</head>

<body>
    <button onclick="sendMessage()">Send Message</button>
    <script>
        const ws = new WebSocket("ws://localhost:3000");
        let peer;
        let dataChannel;
        const config = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };


        ws.onmessage = async (event) => {
            console.log(`Ws message: ${event.data}`)
            if (event.data instanceof Blob) {
                // Convert Blob to text before parsing
                event.data.text().then(text => {
                    const message = JSON.parse(text);
                    handleMessage(message);
                });
            } else {
                // Directly parse if already a string
                const message = JSON.parse(event.data);
                handleMessage(message);
            }
        };
        ws.onopen = () => {
            console.log("WebSocket connected!");
            startConnection(); // Start WebRTC signaling only after WebSocket is open
        };

        async function startConnection() {
            peer = new RTCPeerConnection(config);
            peer.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ ice: event.candidate }));
                }
            };

            peer.ondatachannel = (event) => {
                dataChannel = event.channel;
                dataChannel.onmessage = (e) => console.log("Received:", e.data);
            };
            dataChannel = peer.createDataChannel("chat");
            dataChannel.onopen = () => console.log("DataChannel Open");
            dataChannel.onmessage = (e) => console.log("Received:", e.data);

            const offer = await peer.createOffer();
            await peer.setLocalDescription(offer);

            // Ensure WebSocket is open before sending
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ offer }));
            } else {
                ws.addEventListener("open", () => ws.send(JSON.stringify({ offer })), { once: true });
            }
        }
        function handleMessage(message) {
            if (message.offer) {
                peer.setRemoteDescription(new RTCSessionDescription(message.offer))
                    .then(() => peer.createAnswer())
                    .then(answer => peer.setLocalDescription(answer))
                    .then(() => ws.send(JSON.stringify({ answer: peer.localDescription })));
            } else if (message.answer) {
                if (peer.signalingState === "have-local-offer") {
                    peer.setRemoteDescription(new RTCSessionDescription(message.answer));
                } else {
                    console.warn("Ignoring duplicate answer");
                }
            } else if (message.ice) {
                peer.addIceCandidate(new RTCIceCandidate(message.ice));
            }
        }


        function sendMessage() {
            console.log("Clicked!")
            if (dataChannel && dataChannel.readyState === "open") {
                dataChannel.send("Hello Peer!");
            }
        }

        startConnection();
    </script>
</body>

</html>